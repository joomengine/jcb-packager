	/**
	 * Generate the main README for the JCB Custom Codes repository in Markdown format.
	 *
	 * Provides accurate descriptions of both custom code injection methods:
	 *   1) Placeholder reuse with [CUSTOMCODE=...]
	 *   2) File-level insert/replace tags for persistent customization
	 *
	 * @param  array  $items  All custom code entries stored in the repository.
	 *
	 * @return string  The full generated Markdown README.
	 * @since  5.1.1
	 */
	public function get(array $items): string
	{
		$readme = [];

		// Header
		$readme[] = '# JCB! Custom Codes';
		$readme[] = '';

		// Overview
		$readme[] = '### What Are Custom Codes in JCB?';
		$readme[] = <<<MD
Custom Codes in JCB allow you to create and manage custom logic that can be reused, shared, and even injected  
into your component code at compile time. This feature supports **two advanced use cases**:

1. **Reusable Code Blocks with Argument Injection**
	called: **JCB (manual)**
2. **Persistent File Modification via Insert/Replace Tags**
	called: **Hash (automation)**

---
MD;

		// Section 1: Placeholder Injection
		$readme[] = '### 1. Reusable Code Injection with `[CUSTO' . 'MCODE=...]` (JCB manual)';
		$example = '[CUSTOM' . 'CODE=mainReadmePackageFooter]';
		$example_ = '[CUSTOM' . 'CODE=mainReadmePackageFooter+foo,bar,baz]';
		$readme[] = <<<MD
This method allows you to define a custom code block once and inject it into any JCB-supported code area  
using a placeholder like:

```text
{$example}
````

You can also pass **dynamic arguments** into these placeholders:

```text
{$example_}
```

Your custom code may then reference these values using zero-based placeholders:

* `[[[arg0]]]` ‚Üí `foo`
* `[[[arg1]]]` ‚Üí `bar`
* `[[[arg2]]]` ‚Üí `baz`

If your code uses `n` placeholders, **you must pass `n` arguments** during use.

> üß† **Encoding Special Characters:**
> To include reserved characters in arguments, use these HTML-safe equivalents:
> `[` ‚áí `&#91;`   `]` ‚áí `&#93;`   `,` ‚áí `&#44;`   `+` ‚áí `&#43;`   `=` ‚áí `&#61;`

#### Scope of Use:

* Works in any JCB code area (PHP, JS, HTML, etc.)
* Can be used **within other custom codes**
* ‚ùó **Cannot be used inside its own definition or in IDE hash automation code**

#### Note on Editor Sync:

At present, argument-based custom codes **cannot be reversed back from the compiled project into the UI**
without losing the `[[[argX]]]` placeholders. All updates for such code **must be done via the JCB UI**
until this limitation is resolved.

---
MD;

		// Section 2: Insert/Replace in Files
		$readme[] = '### 2. Persistent File Overrides via Insert/Replace Tags (Hash automation)';
		$exsample = 'INSERT<>';
		$readme[] = <<<MD
When working with a compiled component installed on the same Joomla instance as JCB,
you can **insert or replace blocks of code** inside the actual generated files using special comment tags like:

```php
/***[{$exsample}$$$$]***/
// your code
/***[/{$exsample}$$$$]***/
```

JCB scans for these tags and:

* Extracts the content
* Stores it in the Custom Code UI
* Keeps track of the file and line number
* Re-injects the code on future compilations

This works for both **PHP** and **HTML** using appropriately formatted tag styles.

If the injection location becomes ambiguous, JCB will:

* Comment out the custom code block
* Warn you about the issue
* Preserve the code for manual review

üìò Full tag syntax reference available here:
üëâ [TIPS: Custom Code](https://git.vdm.dev/joomla/Component-Builder/wiki/TIPS:-Custom-Code)

---
MD;

		// Section 3: Language String Extraction
		$readme[] = '### 3. Reverse Engineering of Language Strings';
		$exsample = 'xt::_';
		$readme[] = <<<MD
When custom code uses `Te{$exsample}('SOME_CONSTANT')` language strings, JCB automatically converts them
**back into their readable string form** when importing into the editor. This improves maintainability
by letting you work with the original values rather than language constants.

---
MD;

		// Section 4: Git Workflow & Customization
		$readme[] = '### 4. Customization, Forking, and Version Control';
		$readme[] = <<<MD
As with other JCB entities, Custom Codes support a Git-based workflow:

* **Init**: Import from a repository
* **Reset**: Overwrite with the repository version
* **Push**: Update a shared repository if you have write access
* **Fork**: Maintain and manage your own custom code set

This design encourages collaborative and modular development across multiple JCB projects.

---
MD;

		// Index of available entries
		$readme[] = '### Index of Custom Codes';
		$readme[] = '';

		$readme[] = $this->getIndex($items);
		$readme[] = '';
[CUSTOMCODE=mainReadmePackageFooter]

		return implode("\n", $readme);

	}