	/**
	 * Save content remotely
	 *
	 * @param array   $items    The file array
	 *
	 * @return bool
	 * @since 3.2.2
	 */
	public function items(array $items): bool
	{
		if (empty($items))
		{
			return false;
		}

		$this->grep->setBranchField('write_branch');
		$table = $this->getTable();
		$area = $this->getArea();

		if (!$this->canWrite())
		{
			$target_network = $this->grep->getNetworkTarget() ?? $area;
			$this->messages->add('error', Text::sprintf('At least one [%s] content repository must be configured with a [Write Branch] value in the repositories area, for the push function to operate correctly.', $target_network));
			return false;
		}

		$counter = 0;
		foreach ($items as $item)
		{
			if ($this->save((object) $item))
			{
				$counter++;
			}
		}

		// update the repos main readme and index settings
		if ($this->settings !== [])
		{
			foreach ($this->settings as $repo)
			{
				$this->saveRepoMainSettings($repo);
			}
		}

		// add a message per area once
		if ($counter > 0 && !$this->tracker->exists("message.{$table}{$area}"))
		{
			$this->tracker->set("message.{$table}{$area}", true);
			$item_name = $counter == 1 ? 'item has' : 'items have';
			$this->messages->add('success', Text::sprintf('%s %s been pushed successfully.', $area, $item_name));
		}

		return $counter === count($items);
	}

	/**
	 * Save an item remotely
	 *
	 * @param  object   $item   The item to save
	 *
	 * @return bool
	 * @since  5.1.1
	 */
	protected function save(object $item): bool
	{
		$area = $this->getArea();
		$guid = $item->key ?? null;
		$pointer = $item->pointer ?? null;
		$value = $item->value ?? null;
		$entity = $item->entity ?? null;
		$target = $item->target ?? null;
		$full_path = $item->full ?? null;

		if (empty($guid) || empty($value) || empty($entity) || empty($target) || empty($pointer))
		{
			$this->messages->add('error',
				Text::sprintf('%s had ::missing:: values [guid:%s, pointer: %s, value:%s, entity:%s, target:%s].',
					$area,
					$guid ?? 'missing',
					$pointer ?? 'missing',
					$value ?? 'missing',
					$entity ?? 'missing',
					$target ?? 'missing'
				)
			);
			return false;
		}

		if (empty($full_path) || (!is_file($full_path) && !is_dir($full_path)))
		{
			$this->messages->add('error',
				Text::sprintf('%s:%s [%s] could not be ::found:: at full path:%s.',
					$area, $target, $value, $full_path ?? 'missing'));
			return false;
		}

		// check if we have saved this entity already
		if ($this->tracker->exists("{$entity}.save.{$pointer}"))
		{
			return $this->tracker->get("{$entity}.save.{$pointer}");
		}

		$item->content = $this->getContent($full_path, $guid);

		if (empty($item->content))
		{
			$this->messages->add('error',
				Text::sprintf('%s:%s [%s] could not be ::loaded:: from full path:%s.',
					$area, $target, $value, $full_path ?? 'missing'));
			return false;
		}

		$item->sha = sha1("blob " . strlen($item->content) . "\0" . $item->content);

		$at_least_once = false;
		$not_approved = true;
		foreach ($this->repos as $key => $repo)
		{
			if (empty($repo->write_branch) || $repo->write_branch === 'default' || !$this->targetRepo($item, $repo))
			{
				continue;
			}
			$not_approved = false;

			$this->setRepoPlaceholders($repo);

			// set the target system
			$target_system = $repo->target ?? 'gitea';
			$this->git->setTarget($target_system);

			// load the base and token if set
			$target_system === 'gitea'
				? $this->grep->loadApi($this->git, $repo->base ?? null, $repo->token ?? null)
				: $this->grep->loadApi($this->git, null, $repo->token ?? null);

			try {
				if (($existing = $this->grep->get($guid, ['remote'], $repo)) !== null)
				{
					if ($this->updateItem($item, $existing, $repo))
					{
						$at_least_once = true;
					}
				}
				elseif ($this->createItem($item, $repo))
				{
					$index_item ??= $this->getIndexItem($item);

					$at_least_once = true;

					if (!isset($this->settings[$key]))
					{
						$this->settings[$key] = ['repo' => $repo, 'items' => [$guid => $index_item]];
					}
					else
					{
						$this->settings[$key]['items'][$guid] = $index_item;
						$this->settings[$key]['repo'] = $repo;
					}
				}
				else
				{
					$repo_name = $this->getRepoName($repo);
					$this->messages->add('error', Text::sprintf('%s:%s could not be ::created:: or ::found:: in repo(%s).', $area, $value, $repo_name));
				}
			} catch (\Throwable $e) {
				$repo_name = $this->getRepoName($repo);
				$this->messages->add('error',
					Text::sprintf('%s:%s encountered an ::error:: in repo(%s).<br><br><b>Error Message</b>:<br>%s',
						$area, $value, $repo_name, $e->getMessage()));
			} finally {
				$this->git->reset_();
			}
		}

		if (!$at_least_once && $not_approved)
		{
			$this->messages->add('warning', Text::sprintf('%s:%s is not ::approved:: and therefore not ::linked:: to any repository.', $area, $value));
		}

		$this->tracker->set("{$entity}.save.{$pointer}", $at_least_once);

		return $at_least_once;
	}

	/**
	 * Get the content
	 *
	 * @param  string   $fullPath  The full path to the content
	 * @param  string   $guid        The content key/guid
	 *
	 * @return string|null
	 * @since  5.1.1
	 */
	abstract protected function getContent(string $fullPath, string $guid): ?string;

	/**
	 * update an existing item (if changed)
	 *
	 * @param object $item
	 * @param object $existing
	 * @param object $repo
	 *
	 * @return bool
	 * @since  5.0.3
	 */
	protected function updateItem(object $item, object $existing, object $repo): bool
	{
		$sha = $existing->params->source[$repo->guid . '-settings'] ?? null;
		$area = $this->getArea();
		$item_name = $this->index_map_IndexName($item);
		$repo_name = $this->getRepoName($repo);

		if ($sha === null || $item->sha === $sha)
		{
			$this->messages->add('warning', Text::sprintf('NO CHANGE: %s item [%s] in repo (%s) is already in sync.', $area, $item_name, $repo_name));
			return false;
		}

		$result = $this->git->update(
			$repo->organisation, // The owner name.
			$repo->repository, // The repository name.
			$this->index_map_IndexSettingsPath($item), // The file path.
			$item->content, // The file content.
			'Update ' . $item_name, // The commit message.
			$sha, // The blob SHA of the old file.
			$repo->write_branch // The branch name.
		);

		$success = is_object($result);

		if (!$success)
		{
			$this->messages->add('warning', Text::sprintf('%s item [%s] details in repo(%s) failed to update.', $area, $item_name, $repo_name));
		}

		return $success;
	}

	/**
	 * create a new item
	 *
	 * @param object  $item
	 * @param object  $repo
	 *
	 * @return bool
	 * @since  5.0.3
	 */
	protected function createItem(object $item, object $repo): bool
	{
		$result = $this->git->create(
			$repo->organisation, // The owner name.
			$repo->repository, // The repository name.
			$this->index_map_IndexSettingsPath($item), // The file path.
			$item->content, // The file content.
			'Create ' . $this->index_map_IndexName($item), // The commit message.
			$repo->write_branch // The branch name.
		);

		return is_object($result);
	}